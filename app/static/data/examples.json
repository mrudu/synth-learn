{
	"twoarbiter": {
		"title": "Arbiter with Two Processes",
		"subtitle": "Controller to arbitrate access of two processes to critical section.",
		"html": "twoArbiter.html",
		"id": "SimpleArbiter2",
		"url": "/documentation/twoarbiter",
		"assumptions": [],
		"guarantees": ["G (p -> F (gp))", "G (q -> F (gq))", "G (!gp | !gq)"],
		"inputs": "p, q",
		"outputs": "gp, gq",
		"traces": ["p & q.gp & !gq"]
	},
	"twoarbiterdelay": {
		"title": "Arbiter with Two Processes And Delay",
		"subtitle": "Controller to arbitrate access of two processes to critical section with an additional condition: if no pending request, at next request, grant has atleast one timestep delay",
		"html": "twoArbiter.html",
		"id": "SimpleArbiter2",
		"url": "/documentation/twoarbiter",
		"assumptions": [],
		"guarantees": ["G (p -> F (gp))", "G (q -> F (gq))", "G (!gp | !gq)"],
		"inputs": "p, q",
		"outputs": "gp, gq",
		"traces": ["true.!gp & !gq",
			"p & !q.!gp & !gq.true.gp & !gq",
			"!p & q.!gp & !gq.true.!gp & gq"]
	},
	"twoarbiteralternatinggrants": {
		"title": "Arbiter with Two Processes And Alternating Grants",
		"subtitle": "Controller to arbitrate access of two processes to critical section with additional fairness condition: at concurrent requests, grant to process that was not the last granted",
		"html": "twoArbiter.html",
		"id": "SimpleArbiter2",
		"url": "/documentation/twoarbiter",
		"assumptions": [],
		"guarantees": ["G (p -> F (gp))", "G (q -> F (gq))", "G (!gp | !gq)"],
		"inputs": "p, q",
		"outputs": "gp, gq",
		"traces": ["pr1 = p & q.gp & !gq",
			"pr2 = p & q.!gp & gq",
			"noreqgrant = !p & !q.!gp & !gq",
			"grant1 = gp & !gq",
			"grant2 = !gp & gq",
			"noreqgrant",
			"!p & q.grant2.pr1",
			"p & !q.grant1.pr2",
			"!p & q.grant2.!p & q.grant2.pr1",
			"p & !q.grant1.p & !q.grant1.pr2",
			"!p & q.grant2.noreqgrant.pr1",
			"p & !q.grant1.noreqgrant.pr2"]
	},
	"threearbiter": {
		"title": "Arbiter with Three Processes",
		"subtitle": "Controller to arbitrate access of three processes to critical section.",
		"html": "threeArbiter.html",
		"id": "SimpleArbiter3",
		"url": "/documentation/threearbiter",
		"assumptions": [],
		"guarantees": 
			["G (p -> F (gp))",
			"G (r -> F (gr))",
			"G (q -> F (gq))",
			"G (!(gp & gq) & !(gp & gr) & !(gr & gq))"],
		"inputs": "p, q, r",
		"outputs": "gp, gq, gr",
		"traces": ["p & q & r.gp & !gq & !gr"]
	},
	"towercrane": {
		"title": "Tower Cranes",
		"subtitle": "System with multiple cranes and an overlapping section access arbitrated by controller",
		"html": "towercrane.html",
		"id": "TowerCranes2",
		"url": "/documentation/towercrane",
		"assumptions": [
			"G(r1 -> (r1 W g1))",
			"G(r2 -> (r2 W g2))",
			"G(g1 -> F (l1))",
			"G(g2 -> F (l2))",
			"G (!(r1 & l1))",
			"G (!(r2 & l2))"],
		"guarantees" : [
			"G (r1 -> F (g1))",
			"G (r2 -> F (g2))",
			"G (g1 -> (g1 U X(l1)))",
			"G (g2 -> (g2 U X(l2)))",
			"G (!(g1 & g2))"],
		"inputs": "r1, r2, l1, l2",
		"outputs": "g1, g2",
		"traces": ["!r1 & r2.!g1 & g2",
			"!r1 & !r2.!g1 & !g2",
			"r1 & !r2.g1 & !g2"]
	},
	"liftfloor": {
		"title": "Lift Floors",
		"subtitle": "Controller arbitrates movement of elevator between two floors",
		"html": "liftfloor.html",
		"id": "LiftFloor2",
		"url": "/documentation/liftfloor",
		"assumptions": [
			"G(b0 -> (b0 W (f0 & serve)))",
			"G(b1 -> (b1 W (f1 & serve)))"],
		"guarantees" :
			["G (b0 -> F (f0 & serve))",
			"G (b1 -> F (f1 & serve))",
			"G ((f0 & !f1) | (!f0 & f1))",
			"G ((f0 & serve) -> X (!f1))",
			"G ((f1 & serve) -> X (!f0))",
			"f0"],
		"inputs": "b0, b1",
		"outputs": "f0, f1, serve",
		"traces": [
			"!b0 & b1.f0 & !f1 & !serve.!b0 & b1.!f0 & f1 & serve.!b0 & !b1.!f0 & f1 & !serve.!b0 & !b1.!f0 & f1 & !serve",
			"!b0 & !b1.f0 & !f1 & !serve.!b0 & !b1.f0 & !f1 & !serve"]
	},
	"index": {
		"title": "SynthLearn: Tool for User-Guided Synthesis",
		"subtitle": "Combining automata learning with formal methods",
		"html": "index.html",
		"url": "/documentation/index",
		"id": "ignore"
	}
}